{"version":3,"sources":["helpers/api.js","containers/MasterChatRoom/ConversationChat.js","redux/chatRoom/actions/loadMessages.js"],"names":["_ref","apiURL","concat","api","Object","asyncToGenerator","regenerator_default","a","mark","_callee","url","options","optionsWithHeaders","wrap","_context","prev","next","objectSpread","headers","abrupt","fetch","stop","this","_x","_x2","apply","arguments","ConversationChat","props","_this","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","state","message","conversation","getConversationFriend","id","_this$props","user","friends","myId","fullName","getMappedMessages","messages","map","_id","text","createdAt","userId","name","reverse","_onSend","socket","emit","conversationId","conversations","currentConversationId","senderId","receiverId","Date","_onCreatConversation","SocketIOClient","on","console","log","react_default","createElement","es_button","onClick","React","Component","navigationOptions","_ref2","navigation","title","connect","dispatch","onLoadMessages","callApi","method","Content-Type","then","response","json","error","type","loadMessagesSuccess","catch","err","loadMessages","onSendMessage","sendMessage"],"mappings":"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","file":"static/js/9.593985bf.chunk.js","sourcesContent":["/* @flow */\n\n\n\n\nconst host = 'localhost';\nconst port = 8888;\nconst apiURL = `http://${host}:${port}`;\n\nexport default async (url: string, options: Object) => {\n//  const token = await AsyncStorage.getItem('jwtToken');\n  const optionsWithHeaders = {\n        ...options,\n        headers: {\n          ...options.headers,\n          //Authorization: `Bearer ${token}`,\n        },\n      }\n  return fetch(apiURL + url, optionsWithHeaders);\n};\n","/* @flow */\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport { Button } from 'antd';\n\nimport SocketIOClient from 'socket.io-client';\n\n\nimport { loadMessages, sendMessage } from '../../redux/chatRoom/actions/loadMessages';\n\n\n//import GoBack from '../components/GoBackButton';\n\nimport type { User, Friend, Message } from '../types/types';\n\n\ntype Props = {\n  onSendMessage: (string, Message) => Message,\n  onLoadMessages: string => Message[],\n  navigation: any,\n  messages?: Message[],\n  user: User,\n  friends: { [key: string]: Friend },\n};\n\ntype State = {\n  message: string,\n};\n\nclass ConversationChat extends React.Component<void, Props, State> {\n  socket: Object;\n\n  static navigationOptions = ({ navigation }) => ({\n    title: 'Chat',\n  });\n\n  constructor(props) {\n    super(props);\n\n\n\n    const host = 'localhost';\n    const port = '3000';\n    this.socket = SocketIOClient(`http://${host}:${port}`);\n    this.socket.emit('init', {\n      senderId: 'userid2',\n    });\n    this.socket.on('message', message => {\n      console.log(message)\n\n    });\n  }\n\n  state = {\n    message: '',\n    conversation:{},\n  };\n\n  componentWillMount() {\n    // this.props.onLoadMessages(\n    //   this.props.navigation.state.params.conversation.id,\n    // );\n  }\n\n  componentWillUnmount() {\n    this.socket.emit('disconnect', {\n      senderId: this.props.user.myId,\n    });\n  }\n\n  getConversationFriend = id => {\n    const { user, friends } = this.props;\n    return id === user.myId ? user.fullName : friends[id].fullName;\n  };\n\n  getMappedMessages = () => {\n    return this.props.messages\n      ? this.props.messages\n          .map(({ _id, text, createdAt, userId }) => {\n            return {\n              _id,\n              text,\n              createdAt,\n              user: {\n                _id: userId,\n                name: this.getConversationFriend(userId),\n              },\n            };\n          })\n          .reverse()\n      : [];\n  };\n\n  _onSend = message => {\n\n\n    const { user } = this.props;\n    this.socket.emit('message', {\n      conversationId: this.props.conversations.currentConversationId,\n      text: 'asdf',\n      senderId: user.myId,\n      receiverId: 'userid2',\n      createdAt: new Date(),\n      //msgId: message[0]._id,\n    });\n    // const newMessage = {\n    //   createdAt: message[0].createdAt,\n    //   text: message[0].text,\n    //   userId:'userid1',\n    //   _id: message[0]._id,\n    // };\n    //onSendMessage('conversation.id', newMessage);\n  };\n\n  _onCreatConversation = () => {\n\n\n  }\n\n  render() {\n    return (\n      <div>\n        <Button onClick = {this._onCreatConversation()}>conversation</Button>\n\n        <Button onClick = {this._onSend}>message</Button>\n      </div>\n      // <GiftedChat\n      //   messages={this.getMappedMessages()}\n      //   onSend={this._onSend}\n      //   user={{ _id: this.props.user.myId }}\n      // />\n    );\n  }\n}\n\nfunction mapStateToProps(state) {\n  //console.log(state)\n  return {\n    user: {myId:'userid1'},\n    messages: state.messages[state.conversations.currentConversationId],\n    friends: state.friends.friends,\n    conversations:state.conversations,\n    conversation:state.conversations[state.conversations.currentConversationId]\n  };\n}\n\nexport default connect(\n  mapStateToProps,\n  dispatch => ({\n    onLoadMessages: conversationId => {\n      dispatch(loadMessages(conversationId));\n    },\n    onSendMessage: (conversationId, message) => {\n      dispatch(sendMessage(conversationId, message));\n    },\n  }),\n)(ConversationChat);\n","import callApi from '../../../helpers/api';\n\nexport const loadMessagesSuccess = ({ messages, id }) => ({\n  type: 'LOAD_MESSAGES_SUCCESS',\n  id,\n  messages,\n});\n\nexport const loadMessagesFailure = () => ({\n  type: 'LOAD_MESSAGES_FAILURE',\n});\n\nexport const loadMessages = conversationId => dispatch => {\n  callApi(`/messages/${conversationId}`, {\n    method: 'GET',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  })\n    .then(response => response.json())\n    .then(messages => {\n      if (!messages.error) {\n        dispatch(loadMessagesSuccess(messages));\n      } else {\n        dispatch(loadMessagesFailure(messages.message));\n      }\n    })\n    .catch(err => {\n      console.log(err);\n    });\n  return {\n    type: 'LOAD_MESSAGES',\n  };\n};\n\nexport const sendMessage = (conversationId, message) => ({\n  type: 'SEND_MESSAGE',\n  conversationId,\n  message,\n});\n"],"sourceRoot":""}